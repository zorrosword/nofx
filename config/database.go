package config

import (
	"crypto/rand"
	"database/sql"
	"encoding/base32"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"nofx/crypto"
	"nofx/market"
	"os"
	"slices"
	"strings"
	"time"

	_ "modernc.org/sqlite"
)

// DatabaseInterface å®šä¹‰äº†æ•°æ®åº“å®ç°éœ€è¦æä¾›çš„æ–¹æ³•é›†åˆ
type DatabaseInterface interface {
	SetCryptoService(cs *crypto.CryptoService)
	CreateUser(user *User) error
	GetUserByEmail(email string) (*User, error)
	GetUserByID(userID string) (*User, error)
	GetAllUsers() ([]string, error)
	UpdateUserOTPVerified(userID string, verified bool) error
	GetAIModels(userID string) ([]*AIModelConfig, error)
	UpdateAIModel(userID, id string, enabled bool, apiKey, customAPIURL, customModelName string) error
	GetExchanges(userID string) ([]*ExchangeConfig, error)
	UpdateExchange(userID, id string, enabled bool, apiKey, secretKey string, testnet bool, hyperliquidWalletAddr, asterUser, asterSigner, asterPrivateKey, lighterWalletAddr, lighterPrivateKey string) error
	CreateAIModel(userID, id, name, provider string, enabled bool, apiKey, customAPIURL string) error
	CreateExchange(userID, id, name, typ string, enabled bool, apiKey, secretKey string, testnet bool, hyperliquidWalletAddr, asterUser, asterSigner, asterPrivateKey string) error
	CreateTrader(trader *TraderRecord) error
	GetTraders(userID string) ([]*TraderRecord, error)
	UpdateTraderStatus(userID, id string, isRunning bool) error
	UpdateTrader(trader *TraderRecord) error
	UpdateTraderInitialBalance(userID, id string, newBalance float64) error
	UpdateTraderCustomPrompt(userID, id string, customPrompt string, overrideBase bool) error
	DeleteTrader(userID, id string) error
	GetTraderConfig(userID, traderID string) (*TraderRecord, *AIModelConfig, *ExchangeConfig, error)
	GetSystemConfig(key string) (string, error)
	SetSystemConfig(key, value string) error
	CreateUserSignalSource(userID, coinPoolURL, oiTopURL string) error
	GetUserSignalSource(userID string) (*UserSignalSource, error)
	UpdateUserSignalSource(userID, coinPoolURL, oiTopURL string) error
	GetCustomCoins() []string
	LoadBetaCodesFromFile(filePath string) error
	ValidateBetaCode(code string) (bool, error)
	UseBetaCode(code, userEmail string) error
	GetBetaCodeStats() (total, used int, err error)
	Close() error
}

// Database é…ç½®æ•°æ®åº“
type Database struct {
	db            *sql.DB
	cryptoService *crypto.CryptoService
}

// NewDatabase åˆ›å»ºé…ç½®æ•°æ®åº“
func NewDatabase(dbPath string) (*Database, error) {
	db, err := sql.Open("sqlite", dbPath)
	if err != nil {
		return nil, fmt.Errorf("æ‰“å¼€æ•°æ®åº“å¤±è´¥: %w", err)
	}
	db.SetMaxOpenConns(1)
	db.SetMaxIdleConns(1)
	if _, err := db.Exec(`PRAGMA foreign_keys = ON`); err != nil {
		return nil, fmt.Errorf("å¯ç”¨å¤–é”®å¤±è´¥: %w", err)
	}
	if err := tuneSQLiteConnection(db); err != nil {
		return nil, err
	}

	// ğŸ”’ å¯ç”¨ WAL æ¨¡å¼,æé«˜å¹¶å‘æ€§èƒ½å’Œå´©æºƒæ¢å¤èƒ½åŠ›
	// WAL (Write-Ahead Logging) æ¨¡å¼çš„ä¼˜åŠ¿:
	// 1. æ›´å¥½çš„å¹¶å‘æ€§èƒ½:è¯»æ“ä½œä¸ä¼šè¢«å†™æ“ä½œé˜»å¡
	// 2. å´©æºƒå®‰å…¨:å³ä½¿åœ¨æ–­ç”µæˆ–å¼ºåˆ¶ç»ˆæ­¢æ—¶ä¹Ÿèƒ½ä¿è¯æ•°æ®å®Œæ•´æ€§
	// 3. æ›´å¿«çš„å†™å…¥:ä¸éœ€è¦æ¯æ¬¡éƒ½å†™å…¥ä¸»æ•°æ®åº“æ–‡ä»¶
	if _, err := db.Exec("PRAGMA journal_mode=WAL"); err != nil {
		db.Close()
		return nil, fmt.Errorf("å¯ç”¨WALæ¨¡å¼å¤±è´¥: %w", err)
	}

	// ğŸ”’ è®¾ç½® synchronous=FULL ç¡®ä¿æ•°æ®æŒä¹…æ€§
	// FULL (2) æ¨¡å¼: ç¡®ä¿æ•°æ®åœ¨å…³é”®æ—¶åˆ»å®Œå…¨å†™å…¥ç£ç›˜
	// é…åˆ WAL æ¨¡å¼,åœ¨ä¿è¯æ•°æ®å®‰å…¨çš„åŒæ—¶è·å¾—è‰¯å¥½æ€§èƒ½
	if _, err := db.Exec("PRAGMA synchronous=FULL"); err != nil {
		db.Close()
		return nil, fmt.Errorf("è®¾ç½®synchronouså¤±è´¥: %w", err)
	}

	database := &Database{db: db}
	if err := database.createTables(); err != nil {
		return nil, fmt.Errorf("åˆ›å»ºè¡¨å¤±è´¥: %w", err)
	}
	if err := database.ensureBacktestRunColumns(); err != nil {
		return nil, fmt.Errorf("åˆå§‹åŒ–å›æµ‹è¡¨ç»“æ„å¤±è´¥: %w", err)
	}

	// ç¡®ä¿å­˜åœ¨é»˜è®¤ç”¨æˆ·ï¼ˆç”¨äºå¤–é”®çº¦æŸå’Œé»˜è®¤é…ç½®ç§å­ï¼‰
	if _, err := db.Exec(`
		INSERT OR IGNORE INTO users (id, email, password_hash, otp_secret, otp_verified)
		VALUES ('default', 'default@local', '__default__', '', 1)
	`); err != nil {
		return nil, fmt.Errorf("åˆ›å»ºé»˜è®¤ç”¨æˆ·å¤±è´¥: %w", err)
	}

	if err := database.initDefaultData(); err != nil {
		return nil, fmt.Errorf("åˆå§‹åŒ–é»˜è®¤æ•°æ®å¤±è´¥: %w", err)
	}

	log.Printf("âœ… æ•°æ®åº“å·²å¯ç”¨ WAL æ¨¡å¼å’Œ FULL åŒæ­¥,æ•°æ®æŒä¹…æ€§å¾—åˆ°ä¿è¯")
	return database, nil
}

// createTables åˆ›å»ºæ•°æ®åº“è¡¨
func (d *Database) createTables() error {
	queries := []string{
		// AIæ¨¡å‹é…ç½®è¡¨
		`CREATE TABLE IF NOT EXISTS ai_models (
			id TEXT PRIMARY KEY,
			user_id TEXT NOT NULL DEFAULT 'default',
			name TEXT NOT NULL,
			provider TEXT NOT NULL,
			enabled BOOLEAN DEFAULT 0,
			api_key TEXT DEFAULT '',
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
			updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
			FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
		)`,

		// äº¤æ˜“æ‰€é…ç½®è¡¨
		`CREATE TABLE IF NOT EXISTS exchanges (
			id TEXT PRIMARY KEY,
			user_id TEXT NOT NULL DEFAULT 'default',
			name TEXT NOT NULL,
			type TEXT NOT NULL, -- 'cex' or 'dex'
			enabled BOOLEAN DEFAULT 0,
			api_key TEXT DEFAULT '',
			secret_key TEXT DEFAULT '',
			testnet BOOLEAN DEFAULT 0,
			-- Hyperliquid ç‰¹å®šå­—æ®µ
			hyperliquid_wallet_addr TEXT DEFAULT '',
			-- Aster ç‰¹å®šå­—æ®µ
			aster_user TEXT DEFAULT '',
			aster_signer TEXT DEFAULT '',
			aster_private_key TEXT DEFAULT '',
			-- LIGHTER ç‰¹å®šå­—æ®µ
			lighter_wallet_addr TEXT DEFAULT '',
			lighter_private_key TEXT DEFAULT '',
			lighter_api_key_private_key TEXT DEFAULT '',
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
			updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
			FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
		)`,

		// ç”¨æˆ·ä¿¡å·æºé…ç½®è¡¨
		`CREATE TABLE IF NOT EXISTS user_signal_sources (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			user_id TEXT NOT NULL,
			coin_pool_url TEXT DEFAULT '',
			oi_top_url TEXT DEFAULT '',
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
			updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
			FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
			UNIQUE(user_id)
		)`,

		// äº¤æ˜“å‘˜é…ç½®è¡¨
		`CREATE TABLE IF NOT EXISTS traders (
			id TEXT PRIMARY KEY,
			user_id TEXT NOT NULL DEFAULT 'default',
			name TEXT NOT NULL,
			ai_model_id TEXT NOT NULL,
			exchange_id TEXT NOT NULL,
			initial_balance REAL NOT NULL,
			scan_interval_minutes INTEGER DEFAULT 3,
			is_running BOOLEAN DEFAULT 0,
			btc_eth_leverage INTEGER DEFAULT 5,
			altcoin_leverage INTEGER DEFAULT 5,
			trading_symbols TEXT DEFAULT '',
			use_coin_pool BOOLEAN DEFAULT 0,
			use_oi_top BOOLEAN DEFAULT 0,
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
			updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
			FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
			FOREIGN KEY (ai_model_id) REFERENCES ai_models(id),
			FOREIGN KEY (exchange_id) REFERENCES exchanges(id)
		)`,

		// ç”¨æˆ·è¡¨
		`CREATE TABLE IF NOT EXISTS users (
			id TEXT PRIMARY KEY,
			email TEXT UNIQUE NOT NULL,
			password_hash TEXT NOT NULL,
			otp_secret TEXT,
			otp_verified BOOLEAN DEFAULT 0,
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
			updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
		)`,

		// ç³»ç»Ÿé…ç½®è¡¨
		`CREATE TABLE IF NOT EXISTS system_config (
			key TEXT PRIMARY KEY,
			value TEXT NOT NULL,
			updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
		)`,

		// å›æµ‹è¿è¡Œä¸»è¡¨
		`CREATE TABLE IF NOT EXISTS backtest_runs (
			run_id TEXT PRIMARY KEY,
			user_id TEXT NOT NULL DEFAULT 'default',
			config_json TEXT NOT NULL DEFAULT '',
			state TEXT NOT NULL DEFAULT 'created',
			label TEXT DEFAULT '',
			symbol_count INTEGER DEFAULT 0,
			decision_tf TEXT DEFAULT '',
			processed_bars INTEGER DEFAULT 0,
			progress_pct REAL DEFAULT 0,
			equity_last REAL DEFAULT 0,
			max_drawdown_pct REAL DEFAULT 0,
			liquidated BOOLEAN DEFAULT 0,
			liquidation_note TEXT DEFAULT '',
			prompt_template TEXT DEFAULT '',
			custom_prompt TEXT DEFAULT '',
			override_prompt BOOLEAN DEFAULT 0,
			ai_provider TEXT DEFAULT '',
			ai_model TEXT DEFAULT '',
			last_error TEXT DEFAULT '',
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
			updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
		)`,

		// å›æµ‹æ£€æŸ¥ç‚¹
		`CREATE TABLE IF NOT EXISTS backtest_checkpoints (
			run_id TEXT PRIMARY KEY,
			payload BLOB NOT NULL,
			updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
			FOREIGN KEY (run_id) REFERENCES backtest_runs(run_id) ON DELETE CASCADE
		)`,

		// å›æµ‹æƒç›Šæ›²çº¿
		`CREATE TABLE IF NOT EXISTS backtest_equity (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			run_id TEXT NOT NULL,
			ts INTEGER NOT NULL,
			equity REAL NOT NULL,
			available REAL NOT NULL,
			pnl REAL NOT NULL,
			pnl_pct REAL NOT NULL,
			dd_pct REAL NOT NULL,
			cycle INTEGER NOT NULL,
			FOREIGN KEY (run_id) REFERENCES backtest_runs(run_id) ON DELETE CASCADE
		)`,

		// å›æµ‹äº¤æ˜“è®°å½•
		`CREATE TABLE IF NOT EXISTS backtest_trades (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			run_id TEXT NOT NULL,
			ts INTEGER NOT NULL,
			symbol TEXT NOT NULL,
			action TEXT NOT NULL,
			side TEXT DEFAULT '',
			qty REAL DEFAULT 0,
			price REAL DEFAULT 0,
			fee REAL DEFAULT 0,
			slippage REAL DEFAULT 0,
			order_value REAL DEFAULT 0,
			realized_pnl REAL DEFAULT 0,
			leverage INTEGER DEFAULT 0,
			cycle INTEGER DEFAULT 0,
			position_after REAL DEFAULT 0,
			liquidation BOOLEAN DEFAULT 0,
			note TEXT DEFAULT '',
			FOREIGN KEY (run_id) REFERENCES backtest_runs(run_id) ON DELETE CASCADE
		)`,

		// å›æµ‹æŒ‡æ ‡
		`CREATE TABLE IF NOT EXISTS backtest_metrics (
			run_id TEXT PRIMARY KEY,
			payload BLOB NOT NULL,
			updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
			FOREIGN KEY (run_id) REFERENCES backtest_runs(run_id) ON DELETE CASCADE
		)`,

		// å›æµ‹å†³ç­–æ—¥å¿—
		`CREATE TABLE IF NOT EXISTS backtest_decisions (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			run_id TEXT NOT NULL,
			cycle INTEGER NOT NULL,
			payload BLOB NOT NULL,
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
			FOREIGN KEY (run_id) REFERENCES backtest_runs(run_id) ON DELETE CASCADE
		)`,

		// ç´¢å¼•
		`CREATE INDEX IF NOT EXISTS idx_backtest_runs_state ON backtest_runs(state, updated_at)`,
		`CREATE INDEX IF NOT EXISTS idx_backtest_equity_run_ts ON backtest_equity(run_id, ts)`,
		`CREATE INDEX IF NOT EXISTS idx_backtest_trades_run_ts ON backtest_trades(run_id, ts)`,
		`CREATE INDEX IF NOT EXISTS idx_backtest_decisions_run_cycle ON backtest_decisions(run_id, cycle)`,

		// å†…æµ‹ç è¡¨
		`CREATE TABLE IF NOT EXISTS beta_codes (
			code TEXT PRIMARY KEY,
			used BOOLEAN DEFAULT 0,
			used_by TEXT DEFAULT '',
			used_at DATETIME DEFAULT NULL,
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP
		)`,

		// è§¦å‘å™¨ï¼šè‡ªåŠ¨æ›´æ–° updated_at
		`CREATE TRIGGER IF NOT EXISTS update_users_updated_at
			AFTER UPDATE ON users
			BEGIN
				UPDATE users SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
			END`,

		`CREATE TRIGGER IF NOT EXISTS update_ai_models_updated_at
			AFTER UPDATE ON ai_models
			BEGIN
				UPDATE ai_models SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
			END`,

		`CREATE TRIGGER IF NOT EXISTS update_exchanges_updated_at
			AFTER UPDATE ON exchanges
			BEGIN
				UPDATE exchanges SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
			END`,

		`CREATE TRIGGER IF NOT EXISTS update_traders_updated_at
			AFTER UPDATE ON traders
			BEGIN
				UPDATE traders SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
			END`,

		`CREATE TRIGGER IF NOT EXISTS update_user_signal_sources_updated_at
			AFTER UPDATE ON user_signal_sources
			BEGIN
				UPDATE user_signal_sources SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
			END`,

		`CREATE TRIGGER IF NOT EXISTS update_system_config_updated_at
			AFTER UPDATE ON system_config
			BEGIN
				UPDATE system_config SET updated_at = CURRENT_TIMESTAMP WHERE key = NEW.key;
			END`,
	}

	for _, query := range queries {
		if _, err := d.db.Exec(query); err != nil {
			return fmt.Errorf("æ‰§è¡ŒSQLå¤±è´¥ [%s]: %w", query, err)
		}
	}

	// ä¸ºç°æœ‰æ•°æ®åº“æ·»åŠ æ–°å­—æ®µï¼ˆå‘åå…¼å®¹ï¼‰
	alterQueries := []string{
		`ALTER TABLE exchanges ADD COLUMN hyperliquid_wallet_addr TEXT DEFAULT ''`,
		`ALTER TABLE exchanges ADD COLUMN aster_user TEXT DEFAULT ''`,
		`ALTER TABLE exchanges ADD COLUMN aster_signer TEXT DEFAULT ''`,
		`ALTER TABLE exchanges ADD COLUMN aster_private_key TEXT DEFAULT ''`,
		`ALTER TABLE exchanges ADD COLUMN lighter_wallet_addr TEXT DEFAULT ''`,
		`ALTER TABLE exchanges ADD COLUMN lighter_private_key TEXT DEFAULT ''`,
		`ALTER TABLE exchanges ADD COLUMN lighter_api_key_private_key TEXT DEFAULT ''`,
		`ALTER TABLE traders ADD COLUMN custom_prompt TEXT DEFAULT ''`,
		`ALTER TABLE traders ADD COLUMN override_base_prompt BOOLEAN DEFAULT 0`,
		`ALTER TABLE traders ADD COLUMN is_cross_margin BOOLEAN DEFAULT 1`,             // é»˜è®¤ä¸ºå…¨ä»“æ¨¡å¼
		`ALTER TABLE traders ADD COLUMN use_default_coins BOOLEAN DEFAULT 1`,           // é»˜è®¤ä½¿ç”¨é»˜è®¤å¸ç§
		`ALTER TABLE traders ADD COLUMN custom_coins TEXT DEFAULT ''`,                  // è‡ªå®šä¹‰å¸ç§åˆ—è¡¨ï¼ˆJSONæ ¼å¼ï¼‰
		`ALTER TABLE traders ADD COLUMN btc_eth_leverage INTEGER DEFAULT 5`,            // BTC/ETHæ æ†å€æ•°
		`ALTER TABLE traders ADD COLUMN altcoin_leverage INTEGER DEFAULT 5`,            // å±±å¯¨å¸æ æ†å€æ•°
		`ALTER TABLE traders ADD COLUMN trading_symbols TEXT DEFAULT ''`,               // äº¤æ˜“å¸ç§ï¼Œé€—å·åˆ†éš”
		`ALTER TABLE traders ADD COLUMN use_coin_pool BOOLEAN DEFAULT 0`,               // æ˜¯å¦ä½¿ç”¨COIN POOLä¿¡å·æº
		`ALTER TABLE traders ADD COLUMN use_oi_top BOOLEAN DEFAULT 0`,                  // æ˜¯å¦ä½¿ç”¨OI TOPä¿¡å·æº
		`ALTER TABLE traders ADD COLUMN system_prompt_template TEXT DEFAULT 'default'`, // ç³»ç»Ÿæç¤ºè¯æ¨¡æ¿åç§°
		`ALTER TABLE ai_models ADD COLUMN custom_api_url TEXT DEFAULT ''`,              // è‡ªå®šä¹‰APIåœ°å€
		`ALTER TABLE ai_models ADD COLUMN custom_model_name TEXT DEFAULT ''`,           // è‡ªå®šä¹‰æ¨¡å‹åç§°
	}

	for _, query := range alterQueries {
		// å¿½ç•¥å·²å­˜åœ¨å­—æ®µçš„é”™è¯¯
		d.db.Exec(query)
	}

	// æ£€æŸ¥æ˜¯å¦éœ€è¦è¿ç§»exchangesè¡¨çš„ä¸»é”®ç»“æ„
	err := d.migrateExchangesTable()
	if err != nil {
		log.Printf("âš ï¸ è¿ç§»exchangesè¡¨å¤±è´¥: %v", err)
	}

	return nil
}

func (d *Database) ensureBacktestRunColumns() error {
	addColumn := func(table, column, definition string) error {
		exists, err := columnExists(d.db, table, column)
		if err != nil {
			return err
		}
		if exists {
			return nil
		}
		_, err = d.db.Exec(fmt.Sprintf("ALTER TABLE %s ADD COLUMN %s %s", table, column, definition))
		return err
	}
	if err := addColumn("backtest_runs", "label", "TEXT DEFAULT ''"); err != nil {
		return err
	}
	if err := addColumn("backtest_runs", "last_error", "TEXT DEFAULT ''"); err != nil {
		return err
	}
	if err := addColumn("backtest_trades", "leverage", "INTEGER DEFAULT 0"); err != nil {
		return err
	}
	return nil
}

func columnExists(db *sql.DB, table, column string) (bool, error) {
	rows, err := db.Query(fmt.Sprintf("PRAGMA table_info(%s)", table))
	if err != nil {
		return false, err
	}
	defer rows.Close()
	for rows.Next() {
		var (
			cid        int
			name       string
			ctype      string
			notnull    int
			dfltValue  any
			primaryKey int
		)
		if err := rows.Scan(&cid, &name, &ctype, &notnull, &dfltValue, &primaryKey); err != nil {
			return false, err
		}
		if name == column {
			return true, nil
		}
	}
	return false, rows.Err()
}

func tuneSQLiteConnection(db *sql.DB) error {
	if db == nil {
		return fmt.Errorf("db is nil")
	}
	statements := []string{
		`PRAGMA busy_timeout = 5000`,
		`PRAGMA journal_mode = WAL`,
		`PRAGMA synchronous = NORMAL`,
	}
	for _, stmt := range statements {
		if _, err := db.Exec(stmt); err != nil {
			return fmt.Errorf("æ‰§è¡Œ %s å¤±è´¥: %w", stmt, err)
		}
	}
	return nil
}

// initDefaultData åˆå§‹åŒ–é»˜è®¤æ•°æ®
func (d *Database) initDefaultData() error {
	// åˆå§‹åŒ–AIæ¨¡å‹ï¼ˆä½¿ç”¨defaultç”¨æˆ·ï¼‰
	aiModels := []struct {
		id, name, provider string
	}{
		{"deepseek", "DeepSeek", "deepseek"},
		{"qwen", "Qwen", "qwen"},
	}

	for _, model := range aiModels {
		_, err := d.db.Exec(`
			INSERT OR IGNORE INTO ai_models (id, user_id, name, provider, enabled) 
			VALUES (?, 'default', ?, ?, 0)
		`, model.id, model.name, model.provider)
		if err != nil {
			return fmt.Errorf("åˆå§‹åŒ–AIæ¨¡å‹å¤±è´¥: %w", err)
		}
	}

	// åˆå§‹åŒ–äº¤æ˜“æ‰€ï¼ˆä½¿ç”¨defaultç”¨æˆ·ï¼‰
	exchanges := []struct {
		id, name, typ string
	}{
		{"binance", "Binance Futures", "binance"},
		{"bybit", "Bybit Futures", "bybit"},
		{"hyperliquid", "Hyperliquid", "hyperliquid"},
		{"aster", "Aster DEX", "aster"},
		{"lighter", "LIGHTER DEX", "lighter"},
	}

	for _, exchange := range exchanges {
		_, err := d.db.Exec(`
			INSERT OR IGNORE INTO exchanges (id, user_id, name, type, enabled) 
			VALUES (?, 'default', ?, ?, 0)
		`, exchange.id, exchange.name, exchange.typ)
		if err != nil {
			return fmt.Errorf("åˆå§‹åŒ–äº¤æ˜“æ‰€å¤±è´¥: %w", err)
		}
	}

	// åˆå§‹åŒ–ç³»ç»Ÿé…ç½® - åˆ›å»ºæ‰€æœ‰å­—æ®µï¼Œè®¾ç½®é»˜è®¤å€¼ï¼Œåç»­ç”±config.jsonåŒæ­¥æ›´æ–°
	systemConfigs := map[string]string{
		"beta_mode":            "false",                                                                               // é»˜è®¤å…³é—­å†…æµ‹æ¨¡å¼
		"api_server_port":      "8080",                                                                                // é»˜è®¤APIç«¯å£
		"use_default_coins":    "true",                                                                                // é»˜è®¤ä½¿ç”¨å†…ç½®å¸ç§åˆ—è¡¨
		"default_coins":        `["BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT","DOGEUSDT","ADAUSDT","HYPEUSDT"]`, // é»˜è®¤å¸ç§åˆ—è¡¨ï¼ˆJSONæ ¼å¼ï¼‰
		"max_daily_loss":       "10.0",                                                                                // æœ€å¤§æ—¥æŸå¤±ç™¾åˆ†æ¯”
		"max_drawdown":         "20.0",                                                                                // æœ€å¤§å›æ’¤ç™¾åˆ†æ¯”
		"stop_trading_minutes": "60",                                                                                  // åœæ­¢äº¤æ˜“æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
		"btc_eth_leverage":     "5",                                                                                   // BTC/ETHæ æ†å€æ•°
		"altcoin_leverage":     "5",                                                                                   // å±±å¯¨å¸æ æ†å€æ•°
		"jwt_secret":           "",                                                                                    // JWTå¯†é’¥ï¼Œé»˜è®¤ä¸ºç©ºï¼Œç”±config.jsonæˆ–ç³»ç»Ÿç”Ÿæˆ
		"registration_enabled": "true",                                                                                // é»˜è®¤å…è®¸æ³¨å†Œ
	}

	for key, value := range systemConfigs {
		_, err := d.db.Exec(`
			INSERT OR IGNORE INTO system_config (key, value) 
			VALUES (?, ?)
		`, key, value)
		if err != nil {
			return fmt.Errorf("åˆå§‹åŒ–ç³»ç»Ÿé…ç½®å¤±è´¥: %w", err)
		}
	}

	return nil
}

// migrateExchangesTable è¿ç§»exchangesè¡¨æ”¯æŒå¤šç”¨æˆ·
func (d *Database) migrateExchangesTable() error {
	// æ£€æŸ¥æ˜¯å¦å·²ç»è¿ç§»è¿‡
	var count int
	err := d.db.QueryRow(`
		SELECT COUNT(*) FROM sqlite_master 
		WHERE type='table' AND name='exchanges_new'
	`).Scan(&count)
	if err != nil {
		return err
	}

	// å¦‚æœå·²ç»è¿ç§»è¿‡ï¼Œç›´æ¥è¿”å›
	if count > 0 {
		return nil
	}

	log.Printf("ğŸ”„ å¼€å§‹è¿ç§»exchangesè¡¨...")

	// åˆ›å»ºæ–°çš„exchangesè¡¨ï¼Œä½¿ç”¨å¤åˆä¸»é”®
	_, err = d.db.Exec(`
		CREATE TABLE exchanges_new (
			id TEXT NOT NULL,
			user_id TEXT NOT NULL DEFAULT 'default',
			name TEXT NOT NULL,
			type TEXT NOT NULL,
			enabled BOOLEAN DEFAULT 0,
			api_key TEXT DEFAULT '',
			secret_key TEXT DEFAULT '',
			testnet BOOLEAN DEFAULT 0,
			hyperliquid_wallet_addr TEXT DEFAULT '',
			aster_user TEXT DEFAULT '',
			aster_signer TEXT DEFAULT '',
			aster_private_key TEXT DEFAULT '',
			lighter_wallet_addr TEXT DEFAULT '',
			lighter_private_key TEXT DEFAULT '',
			lighter_api_key_private_key TEXT DEFAULT '',
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
			updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
			PRIMARY KEY (id, user_id),
			FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
		)
	`)
	if err != nil {
		return fmt.Errorf("åˆ›å»ºæ–°exchangesè¡¨å¤±è´¥: %w", err)
	}

	// å¤åˆ¶æ•°æ®åˆ°æ–°è¡¨
	_, err = d.db.Exec(`
		INSERT INTO exchanges_new 
		SELECT * FROM exchanges
	`)
	if err != nil {
		return fmt.Errorf("å¤åˆ¶æ•°æ®å¤±è´¥: %w", err)
	}

	// åˆ é™¤æ—§è¡¨
	_, err = d.db.Exec(`DROP TABLE exchanges`)
	if err != nil {
		return fmt.Errorf("åˆ é™¤æ—§è¡¨å¤±è´¥: %w", err)
	}

	// é‡å‘½åæ–°è¡¨
	_, err = d.db.Exec(`ALTER TABLE exchanges_new RENAME TO exchanges`)
	if err != nil {
		return fmt.Errorf("é‡å‘½åè¡¨å¤±è´¥: %w", err)
	}

	// é‡æ–°åˆ›å»ºè§¦å‘å™¨
	_, err = d.db.Exec(`
		CREATE TRIGGER IF NOT EXISTS update_exchanges_updated_at
			AFTER UPDATE ON exchanges
			BEGIN
				UPDATE exchanges SET updated_at = CURRENT_TIMESTAMP 
				WHERE id = NEW.id AND user_id = NEW.user_id;
			END
	`)
	if err != nil {
		return fmt.Errorf("åˆ›å»ºè§¦å‘å™¨å¤±è´¥: %w", err)
	}

	log.Printf("âœ… exchangesè¡¨è¿ç§»å®Œæˆ")
	return nil
}

// User ç”¨æˆ·é…ç½®
type User struct {
	ID           string    `json:"id"`
	Email        string    `json:"email"`
	PasswordHash string    `json:"-"` // ä¸è¿”å›åˆ°å‰ç«¯
	OTPSecret    string    `json:"-"` // ä¸è¿”å›åˆ°å‰ç«¯
	OTPVerified  bool      `json:"otp_verified"`
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
}

// AIModelConfig AIæ¨¡å‹é…ç½®
type AIModelConfig struct {
	ID              string    `json:"id"`
	UserID          string    `json:"user_id"`
	Name            string    `json:"name"`
	Provider        string    `json:"provider"`
	Enabled         bool      `json:"enabled"`
	APIKey          string    `json:"apiKey"`
	CustomAPIURL    string    `json:"customApiUrl"`
	CustomModelName string    `json:"customModelName"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
}

// ExchangeConfig äº¤æ˜“æ‰€é…ç½®
type ExchangeConfig struct {
	ID        string `json:"id"`
	UserID    string `json:"user_id"`
	Name      string `json:"name"`
	Type      string `json:"type"`
	Enabled   bool   `json:"enabled"`
	APIKey    string `json:"apiKey"`    // For Binance: API Key; For Hyperliquid: Agent Private Key (should have ~0 balance)
	SecretKey string `json:"secretKey"` // For Binance: Secret Key; Not used for Hyperliquid
	Testnet   bool   `json:"testnet"`
	// Hyperliquid Agent Wallet configuration (following official best practices)
	// Reference: https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/nonces-and-api-wallets
	HyperliquidWalletAddr string `json:"hyperliquidWalletAddr"` // Main Wallet Address (holds funds, never expose private key)
	// Aster ç‰¹å®šå­—æ®µ
	AsterUser       string `json:"asterUser"`
	AsterSigner     string `json:"asterSigner"`
	AsterPrivateKey string `json:"asterPrivateKey"`
	// LIGHTER ç‰¹å®šå­—æ®µ
	LighterWalletAddr       string `json:"lighterWalletAddr"`       // Ethereum é’±åŒ…åœ°å€ (L1)
	LighterPrivateKey       string `json:"lighterPrivateKey"`       // L1ç§é’¥ï¼ˆç”¨äºè¯†åˆ«è´¦æˆ·ï¼‰
	LighterAPIKeyPrivateKey string `json:"lighterAPIKeyPrivateKey"` // API Keyç§é’¥ï¼ˆ40å­—èŠ‚ï¼Œç”¨äºç­¾åäº¤æ˜“ï¼‰
	CreatedAt          time.Time `json:"created_at"`
	UpdatedAt          time.Time `json:"updated_at"`
}

// TraderRecord äº¤æ˜“å‘˜é…ç½®ï¼ˆæ•°æ®åº“å®ä½“ï¼‰
type TraderRecord struct {
	ID                   string    `json:"id"`
	UserID               string    `json:"user_id"`
	Name                 string    `json:"name"`
	AIModelID            string    `json:"ai_model_id"`
	ExchangeID           string    `json:"exchange_id"`
	InitialBalance       float64   `json:"initial_balance"`
	ScanIntervalMinutes  int       `json:"scan_interval_minutes"`
	IsRunning            bool      `json:"is_running"`
	BTCETHLeverage       int       `json:"btc_eth_leverage"`       // BTC/ETHæ æ†å€æ•°
	AltcoinLeverage      int       `json:"altcoin_leverage"`       // å±±å¯¨å¸æ æ†å€æ•°
	TradingSymbols       string    `json:"trading_symbols"`        // äº¤æ˜“å¸ç§ï¼Œé€—å·åˆ†éš”
	UseCoinPool          bool      `json:"use_coin_pool"`          // æ˜¯å¦ä½¿ç”¨COIN POOLä¿¡å·æº
	UseOITop             bool      `json:"use_oi_top"`             // æ˜¯å¦ä½¿ç”¨OI TOPä¿¡å·æº
	CustomPrompt         string    `json:"custom_prompt"`          // è‡ªå®šä¹‰äº¤æ˜“ç­–ç•¥prompt
	OverrideBasePrompt   bool      `json:"override_base_prompt"`   // æ˜¯å¦è¦†ç›–åŸºç¡€prompt
	SystemPromptTemplate string    `json:"system_prompt_template"` // ç³»ç»Ÿæç¤ºè¯æ¨¡æ¿åç§°
	IsCrossMargin        bool      `json:"is_cross_margin"`        // æ˜¯å¦ä¸ºå…¨ä»“æ¨¡å¼ï¼ˆtrue=å…¨ä»“ï¼Œfalse=é€ä»“ï¼‰
	CreatedAt            time.Time `json:"created_at"`
	UpdatedAt            time.Time `json:"updated_at"`
}

// UserSignalSource ç”¨æˆ·ä¿¡å·æºé…ç½®
type UserSignalSource struct {
	ID          int       `json:"id"`
	UserID      string    `json:"user_id"`
	CoinPoolURL string    `json:"coin_pool_url"`
	OITopURL    string    `json:"oi_top_url"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// GenerateOTPSecret ç”ŸæˆOTPå¯†é’¥
func GenerateOTPSecret() (string, error) {
	secret := make([]byte, 20)
	_, err := rand.Read(secret)
	if err != nil {
		return "", err
	}
	return base32.StdEncoding.EncodeToString(secret), nil
}

// CreateUser åˆ›å»ºç”¨æˆ·
func (d *Database) CreateUser(user *User) error {
	_, err := d.db.Exec(`
		INSERT INTO users (id, email, password_hash, otp_secret, otp_verified)
		VALUES (?, ?, ?, ?, ?)
	`, user.ID, user.Email, user.PasswordHash, user.OTPSecret, user.OTPVerified)
	return err
}

// EnsureAdminUser ç¡®ä¿adminç”¨æˆ·å­˜åœ¨ï¼ˆç”¨äºç®¡ç†å‘˜æ¨¡å¼ï¼‰
func (d *Database) EnsureAdminUser() error {
	// æ£€æŸ¥adminç”¨æˆ·æ˜¯å¦å·²å­˜åœ¨
	var count int
	err := d.db.QueryRow(`SELECT COUNT(*) FROM users WHERE id = 'admin'`).Scan(&count)
	if err != nil {
		return err
	}

	// å¦‚æœå·²å­˜åœ¨ï¼Œç›´æ¥è¿”å›
	if count > 0 {
		return nil
	}

	// åˆ›å»ºadminç”¨æˆ·ï¼ˆå¯†ç ä¸ºç©ºï¼Œå› ä¸ºç®¡ç†å‘˜æ¨¡å¼ä¸‹ä¸éœ€è¦å¯†ç ï¼‰
	adminUser := &User{
		ID:           "admin",
		Email:        "admin@localhost",
		PasswordHash: "", // ç®¡ç†å‘˜æ¨¡å¼ä¸‹ä¸ä½¿ç”¨å¯†ç 
		OTPSecret:    "",
		OTPVerified:  true,
	}

	return d.CreateUser(adminUser)
}

// GetUserByEmail é€šè¿‡é‚®ç®±è·å–ç”¨æˆ·
func (d *Database) GetUserByEmail(email string) (*User, error) {
	var user User
	err := d.db.QueryRow(`
		SELECT id, email, password_hash, otp_secret, otp_verified, created_at, updated_at
		FROM users WHERE email = ?
	`, email).Scan(
		&user.ID, &user.Email, &user.PasswordHash, &user.OTPSecret,
		&user.OTPVerified, &user.CreatedAt, &user.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}
	return &user, nil
}

// GetUserByID é€šè¿‡IDè·å–ç”¨æˆ·
func (d *Database) GetUserByID(userID string) (*User, error) {
	var user User
	err := d.db.QueryRow(`
		SELECT id, email, password_hash, otp_secret, otp_verified, created_at, updated_at
		FROM users WHERE id = ?
	`, userID).Scan(
		&user.ID, &user.Email, &user.PasswordHash, &user.OTPSecret,
		&user.OTPVerified, &user.CreatedAt, &user.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}
	return &user, nil
}

// GetAllUsers è·å–æ‰€æœ‰ç”¨æˆ·IDåˆ—è¡¨
func (d *Database) GetAllUsers() ([]string, error) {
	rows, err := d.db.Query(`SELECT id FROM users ORDER BY id`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var userIDs []string
	for rows.Next() {
		var userID string
		if err := rows.Scan(&userID); err != nil {
			return nil, err
		}
		userIDs = append(userIDs, userID)
	}
	return userIDs, nil
}

// UpdateUserOTPVerified æ›´æ–°ç”¨æˆ·OTPéªŒè¯çŠ¶æ€
func (d *Database) UpdateUserOTPVerified(userID string, verified bool) error {
	_, err := d.db.Exec(`UPDATE users SET otp_verified = ? WHERE id = ?`, verified, userID)
	return err
}

// UpdateUserPassword æ›´æ–°ç”¨æˆ·å¯†ç 
func (d *Database) UpdateUserPassword(userID, passwordHash string) error {
	_, err := d.db.Exec(`
		UPDATE users
		SET password_hash = ?, updated_at = CURRENT_TIMESTAMP
		WHERE id = ?
	`, passwordHash, userID)
	return err
}

// GetAIModels è·å–ç”¨æˆ·çš„AIæ¨¡å‹é…ç½®
func (d *Database) GetAIModels(userID string) ([]*AIModelConfig, error) {
	rows, err := d.db.Query(`
		SELECT id, user_id, name, provider, enabled, api_key,
		       COALESCE(custom_api_url, '') as custom_api_url,
		       COALESCE(custom_model_name, '') as custom_model_name,
		       created_at, updated_at
		FROM ai_models WHERE user_id = ? ORDER BY id
	`, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	// åˆå§‹åŒ–ä¸ºç©ºåˆ‡ç‰‡è€Œä¸æ˜¯nilï¼Œç¡®ä¿JSONåºåˆ—åŒ–ä¸º[]è€Œä¸æ˜¯null
	models := make([]*AIModelConfig, 0)
	for rows.Next() {
		var model AIModelConfig
		err := rows.Scan(
			&model.ID, &model.UserID, &model.Name, &model.Provider,
			&model.Enabled, &model.APIKey, &model.CustomAPIURL, &model.CustomModelName,
			&model.CreatedAt, &model.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}
		// è§£å¯†API Key
		model.APIKey = d.decryptSensitiveData(model.APIKey)
		models = append(models, &model)
	}

	return models, nil
}

// GetAIModel æ ¹æ®æ¨¡å‹IDå’Œç”¨æˆ·IDè·å–å•ä¸ªAIæ¨¡å‹é…ç½®ï¼Œè‹¥ç”¨æˆ·ä¸‹ä¸å­˜åœ¨åˆ™å›é€€åˆ°defaultç”¨æˆ·ã€‚
func (d *Database) GetAIModel(userID, modelID string) (*AIModelConfig, error) {
	if modelID == "" {
		return nil, fmt.Errorf("æ¨¡å‹IDä¸èƒ½ä¸ºç©º")
	}

	candidates := []string{}
	if userID != "" {
		candidates = append(candidates, userID)
	}
	if userID != "default" {
		candidates = append(candidates, "default")
	}
	if len(candidates) == 0 {
		candidates = append(candidates, "default")
	}

	for _, uid := range candidates {
		var model AIModelConfig
		err := d.db.QueryRow(`
			SELECT id, user_id, name, provider, enabled, api_key,
			       COALESCE(custom_api_url, ''), COALESCE(custom_model_name, ''), created_at, updated_at
			FROM ai_models
			WHERE user_id = ? AND id = ?
			LIMIT 1
		`, uid, modelID).Scan(
			&model.ID,
			&model.UserID,
			&model.Name,
			&model.Provider,
			&model.Enabled,
			&model.APIKey,
			&model.CustomAPIURL,
			&model.CustomModelName,
			&model.CreatedAt,
			&model.UpdatedAt,
		)
		if err == nil {
			// è§£å¯†API Keyï¼ˆä¸ GetAIModels è¡Œä¸ºä¿æŒä¸€è‡´ï¼‰
			model.APIKey = d.decryptSensitiveData(model.APIKey)
			return &model, nil
		}
		if !errors.Is(err, sql.ErrNoRows) {
			return nil, err
		}
	}

	return nil, sql.ErrNoRows
}

// GetDefaultAIModel è·å–æŒ‡å®šç”¨æˆ·ï¼ˆæˆ–é»˜è®¤ç”¨æˆ·ï¼‰çš„é¦–ä¸ªå¯ç”¨çš„AIæ¨¡å‹ã€‚
func (d *Database) GetDefaultAIModel(userID string) (*AIModelConfig, error) {
	if userID == "" {
		userID = "default"
	}
	model, err := d.firstEnabledAIModel(userID)
	if err == nil {
		return model, nil
	}
	if !errors.Is(err, sql.ErrNoRows) {
		return nil, err
	}
	if userID != "default" {
		return d.firstEnabledAIModel("default")
	}
	return nil, fmt.Errorf("è¯·å…ˆåœ¨ç³»ç»Ÿä¸­é…ç½®å¯ç”¨çš„AIæ¨¡å‹")
}

func (d *Database) firstEnabledAIModel(userID string) (*AIModelConfig, error) {
	var model AIModelConfig
	err := d.db.QueryRow(`
		SELECT id, user_id, name, provider, enabled, api_key,
		       COALESCE(custom_api_url, ''), COALESCE(custom_model_name, ''), created_at, updated_at
		FROM ai_models
		WHERE user_id = ? AND enabled = 1
		ORDER BY datetime(updated_at) DESC, id ASC
		LIMIT 1
	`, userID).Scan(
		&model.ID,
		&model.UserID,
		&model.Name,
		&model.Provider,
		&model.Enabled,
		&model.APIKey,
		&model.CustomAPIURL,
		&model.CustomModelName,
		&model.CreatedAt,
		&model.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}
	// è§£å¯†API Keyï¼Œé¿å…ä¸Šå±‚æ‹¿åˆ°åŠ å¯†ä¸²å¯¼è‡´ä¸‹æ¸¸è®¤è¯å¤±è´¥
	model.APIKey = d.decryptSensitiveData(model.APIKey)
	return &model, nil
}

// UpdateAIModel æ›´æ–°AIæ¨¡å‹é…ç½®ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»ºç”¨æˆ·ç‰¹å®šé…ç½®
func (d *Database) UpdateAIModel(userID, id string, enabled bool, apiKey, customAPIURL, customModelName string) error {
	// å…ˆå°è¯•ç²¾ç¡®åŒ¹é… IDï¼ˆæ–°ç‰ˆé€»è¾‘ï¼Œæ”¯æŒå¤šä¸ªç›¸åŒ provider çš„æ¨¡å‹ï¼‰
	var existingID string
	err := d.db.QueryRow(`
		SELECT id FROM ai_models WHERE user_id = ? AND id = ? LIMIT 1
	`, userID, id).Scan(&existingID)

	if err == nil {
		// æ‰¾åˆ°äº†ç°æœ‰é…ç½®ï¼ˆç²¾ç¡®åŒ¹é… IDï¼‰ï¼Œæ›´æ–°å®ƒ
		encryptedAPIKey := d.encryptSensitiveData(apiKey)
		_, err = d.db.Exec(`
			UPDATE ai_models SET enabled = ?, api_key = ?, custom_api_url = ?, custom_model_name = ?, updated_at = datetime('now')
			WHERE id = ? AND user_id = ?
		`, enabled, encryptedAPIKey, customAPIURL, customModelName, existingID, userID)
		return err
	}

	// ID ä¸å­˜åœ¨ï¼Œå°è¯•å…¼å®¹æ—§é€»è¾‘ï¼šå°† id ä½œä¸º provider æŸ¥æ‰¾
	provider := id
	err = d.db.QueryRow(`
		SELECT id FROM ai_models WHERE user_id = ? AND provider = ? LIMIT 1
	`, userID, provider).Scan(&existingID)

	if err == nil {
		// æ‰¾åˆ°äº†ç°æœ‰é…ç½®ï¼ˆé€šè¿‡ provider åŒ¹é…ï¼Œå…¼å®¹æ—§ç‰ˆï¼‰ï¼Œæ›´æ–°å®ƒ
		log.Printf("âš ï¸  ä½¿ç”¨æ—§ç‰ˆ provider åŒ¹é…æ›´æ–°æ¨¡å‹: %s -> %s", provider, existingID)
		encryptedAPIKey := d.encryptSensitiveData(apiKey)
		_, err = d.db.Exec(`
			UPDATE ai_models SET enabled = ?, api_key = ?, custom_api_url = ?, custom_model_name = ?, updated_at = datetime('now')
			WHERE id = ? AND user_id = ?
		`, enabled, encryptedAPIKey, customAPIURL, customModelName, existingID, userID)
		return err
	}

	// æ²¡æœ‰æ‰¾åˆ°ä»»ä½•ç°æœ‰é…ç½®ï¼Œåˆ›å»ºæ–°çš„
	// æ¨æ–­ providerï¼ˆä» id ä¸­æå–ï¼Œæˆ–è€…ç›´æ¥ä½¿ç”¨ idï¼‰
	if provider == id && (provider == "deepseek" || provider == "qwen") {
		// id æœ¬èº«å°±æ˜¯ provider
		provider = id
	} else {
		// ä» id ä¸­æå– providerï¼ˆå‡è®¾æ ¼å¼æ˜¯ userID_provider æˆ– timestamp_userID_providerï¼‰
		parts := strings.Split(id, "_")
		if len(parts) >= 2 {
			provider = parts[len(parts)-1] // å–æœ€åä¸€éƒ¨åˆ†ä½œä¸º provider
		} else {
			provider = id
		}
	}

	// è·å–æ¨¡å‹çš„åŸºæœ¬ä¿¡æ¯
	var name string
	err = d.db.QueryRow(`
		SELECT name FROM ai_models WHERE provider = ? LIMIT 1
	`, provider).Scan(&name)
	if err != nil {
		// å¦‚æœæ‰¾ä¸åˆ°åŸºæœ¬ä¿¡æ¯ï¼Œä½¿ç”¨é»˜è®¤å€¼
		if provider == "deepseek" {
			name = "DeepSeek AI"
		} else if provider == "qwen" {
			name = "Qwen AI"
		} else {
			name = provider + " AI"
		}
	}

	// å¦‚æœä¼ å…¥çš„ ID å·²ç»æ˜¯å®Œæ•´æ ¼å¼ï¼ˆå¦‚ "admin_deepseek_custom1"ï¼‰ï¼Œç›´æ¥ä½¿ç”¨
	// å¦åˆ™ç”Ÿæˆæ–°çš„ ID
	newModelID := id
	if id == provider {
		// id å°±æ˜¯ providerï¼Œç”Ÿæˆæ–°çš„ç”¨æˆ·ç‰¹å®š ID
		newModelID = fmt.Sprintf("%s_%s", userID, provider)
	}

	log.Printf("âœ“ åˆ›å»ºæ–°çš„ AI æ¨¡å‹é…ç½®: ID=%s, Provider=%s, Name=%s", newModelID, provider, name)
	encryptedAPIKey := d.encryptSensitiveData(apiKey)
	_, err = d.db.Exec(`
		INSERT INTO ai_models (id, user_id, name, provider, enabled, api_key, custom_api_url, custom_model_name, created_at, updated_at)
		VALUES (?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
	`, newModelID, userID, name, provider, enabled, encryptedAPIKey, customAPIURL, customModelName)

	return err
}

// GetExchanges è·å–ç”¨æˆ·çš„äº¤æ˜“æ‰€é…ç½®
func (d *Database) GetExchanges(userID string) ([]*ExchangeConfig, error) {
	rows, err := d.db.Query(`
		SELECT id, user_id, name, type, enabled, api_key, secret_key, testnet,
		       COALESCE(hyperliquid_wallet_addr, '') as hyperliquid_wallet_addr,
		       COALESCE(aster_user, '') as aster_user,
		       COALESCE(aster_signer, '') as aster_signer,
		       COALESCE(aster_private_key, '') as aster_private_key,
		       COALESCE(lighter_wallet_addr, '') as lighter_wallet_addr,
		       COALESCE(lighter_private_key, '') as lighter_private_key,
		       created_at, updated_at
		FROM exchanges WHERE user_id = ? ORDER BY id
	`, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	// åˆå§‹åŒ–ä¸ºç©ºåˆ‡ç‰‡è€Œä¸æ˜¯nilï¼Œç¡®ä¿JSONåºåˆ—åŒ–ä¸º[]è€Œä¸æ˜¯null
	exchanges := make([]*ExchangeConfig, 0)
	for rows.Next() {
		var exchange ExchangeConfig
		err := rows.Scan(
			&exchange.ID, &exchange.UserID, &exchange.Name, &exchange.Type,
			&exchange.Enabled, &exchange.APIKey, &exchange.SecretKey, &exchange.Testnet,
			&exchange.HyperliquidWalletAddr, &exchange.AsterUser,
			&exchange.AsterSigner, &exchange.AsterPrivateKey,
			&exchange.LighterWalletAddr, &exchange.LighterPrivateKey,
			&exchange.CreatedAt, &exchange.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}

		// è§£å¯†æ•æ„Ÿå­—æ®µ
		exchange.APIKey = d.decryptSensitiveData(exchange.APIKey)
		exchange.SecretKey = d.decryptSensitiveData(exchange.SecretKey)
		exchange.AsterPrivateKey = d.decryptSensitiveData(exchange.AsterPrivateKey)
		exchange.LighterPrivateKey = d.decryptSensitiveData(exchange.LighterPrivateKey)

		exchanges = append(exchanges, &exchange)
	}

	return exchanges, nil
}

// UpdateExchange æ›´æ–°äº¤æ˜“æ‰€é…ç½®ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»ºç”¨æˆ·ç‰¹å®šé…ç½®
// ğŸ”’ å®‰å…¨ç‰¹æ€§ï¼šç©ºå€¼ä¸ä¼šè¦†ç›–ç°æœ‰çš„æ•æ„Ÿå­—æ®µï¼ˆapi_key, secret_key, aster_private_key, lighter_private_keyï¼‰
func (d *Database) UpdateExchange(userID, id string, enabled bool, apiKey, secretKey string, testnet bool, hyperliquidWalletAddr, asterUser, asterSigner, asterPrivateKey, lighterWalletAddr, lighterPrivateKey string) error {
	log.Printf("ğŸ”§ UpdateExchange: userID=%s, id=%s, enabled=%v", userID, id, enabled)

	// æ„å»ºåŠ¨æ€ UPDATE SET å­å¥
	// åŸºç¡€å­—æ®µï¼šæ€»æ˜¯æ›´æ–°
	setClauses := []string{
		"enabled = ?",
		"testnet = ?",
		"hyperliquid_wallet_addr = ?",
		"aster_user = ?",
		"aster_signer = ?",
		"lighter_wallet_addr = ?",
		"updated_at = datetime('now')",
	}
	args := []interface{}{enabled, testnet, hyperliquidWalletAddr, asterUser, asterSigner, lighterWalletAddr}

	// ğŸ”’ æ•æ„Ÿå­—æ®µï¼šåªåœ¨éç©ºæ—¶æ›´æ–°ï¼ˆä¿æŠ¤ç°æœ‰æ•°æ®ï¼‰
	if apiKey != "" {
		encryptedAPIKey := d.encryptSensitiveData(apiKey)
		setClauses = append(setClauses, "api_key = ?")
		args = append(args, encryptedAPIKey)
	}

	if secretKey != "" {
		encryptedSecretKey := d.encryptSensitiveData(secretKey)
		setClauses = append(setClauses, "secret_key = ?")
		args = append(args, encryptedSecretKey)
	}

	if asterPrivateKey != "" {
		encryptedAsterPrivateKey := d.encryptSensitiveData(asterPrivateKey)
		setClauses = append(setClauses, "aster_private_key = ?")
		args = append(args, encryptedAsterPrivateKey)
	}

	if lighterPrivateKey != "" {
		encryptedLighterPrivateKey := d.encryptSensitiveData(lighterPrivateKey)
		setClauses = append(setClauses, "lighter_private_key = ?")
		args = append(args, encryptedLighterPrivateKey)
	}

	// WHERE æ¡ä»¶
	args = append(args, id, userID)

	// æ„å»ºå®Œæ•´çš„ UPDATE è¯­å¥
	query := fmt.Sprintf(`
		UPDATE exchanges SET %s
		WHERE id = ? AND user_id = ?
	`, strings.Join(setClauses, ", "))

	// æ‰§è¡Œæ›´æ–°
	result, err := d.db.Exec(query, args...)
	if err != nil {
		log.Printf("âŒ UpdateExchange: æ›´æ–°å¤±è´¥: %v", err)
		return err
	}

	// æ£€æŸ¥æ˜¯å¦æœ‰è¡Œè¢«æ›´æ–°
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("âŒ UpdateExchange: è·å–å½±å“è¡Œæ•°å¤±è´¥: %v", err)
		return err
	}

	log.Printf("ğŸ“Š UpdateExchange: å½±å“è¡Œæ•° = %d", rowsAffected)

	// å¦‚æœæ²¡æœ‰è¡Œè¢«æ›´æ–°ï¼Œè¯´æ˜ç”¨æˆ·æ²¡æœ‰è¿™ä¸ªäº¤æ˜“æ‰€çš„é…ç½®ï¼Œéœ€è¦åˆ›å»º
	if rowsAffected == 0 {
		log.Printf("ğŸ’¡ UpdateExchange: æ²¡æœ‰ç°æœ‰è®°å½•ï¼Œåˆ›å»ºæ–°è®°å½•")

		// æ ¹æ®äº¤æ˜“æ‰€IDç¡®å®šåŸºæœ¬ä¿¡æ¯
		var name, typ string
		if id == "binance" {
			name = "Binance Futures"
			typ = "cex"
		} else if id == "bybit" {
			name = "Bybit Futures"
			typ = "cex"
		} else if id == "hyperliquid" {
			name = "Hyperliquid"
			typ = "dex"
		} else if id == "aster" {
			name = "Aster DEX"
			typ = "dex"
		} else if id == "lighter" {
			name = "LIGHTER DEX"
			typ = "dex"
		} else {
			name = id + " Exchange"
			typ = "cex"
		}

		log.Printf("ğŸ†• UpdateExchange: åˆ›å»ºæ–°è®°å½• ID=%s, name=%s, type=%s", id, name, typ)

		// åŠ å¯†æ•æ„Ÿå­—æ®µ
		encryptedAPIKey := d.encryptSensitiveData(apiKey)
		encryptedSecretKey := d.encryptSensitiveData(secretKey)
		encryptedAsterPrivateKey := d.encryptSensitiveData(asterPrivateKey)
		encryptedLighterPrivateKey := d.encryptSensitiveData(lighterPrivateKey)

		// åˆ›å»ºç”¨æˆ·ç‰¹å®šçš„é…ç½®ï¼Œä½¿ç”¨åŸå§‹çš„äº¤æ˜“æ‰€ID
		_, err = d.db.Exec(`
			INSERT INTO exchanges (id, user_id, name, type, enabled, api_key, secret_key, testnet,
			                       hyperliquid_wallet_addr, aster_user, aster_signer, aster_private_key,
			                       lighter_wallet_addr, lighter_private_key, created_at, updated_at)
			VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
		`, id, userID, name, typ, enabled, encryptedAPIKey, encryptedSecretKey, testnet, hyperliquidWalletAddr, asterUser, asterSigner, encryptedAsterPrivateKey, lighterWalletAddr, encryptedLighterPrivateKey)

		if err != nil {
			log.Printf("âŒ UpdateExchange: åˆ›å»ºè®°å½•å¤±è´¥: %v", err)
		} else {
			log.Printf("âœ… UpdateExchange: åˆ›å»ºè®°å½•æˆåŠŸ")
		}
		return err
	}

	log.Printf("âœ… UpdateExchange: æ›´æ–°ç°æœ‰è®°å½•æˆåŠŸ")
	return nil
}

// CreateAIModel åˆ›å»ºAIæ¨¡å‹é…ç½®
func (d *Database) CreateAIModel(userID, id, name, provider string, enabled bool, apiKey, customAPIURL string) error {
	_, err := d.db.Exec(`
		INSERT OR IGNORE INTO ai_models (id, user_id, name, provider, enabled, api_key, custom_api_url) 
		VALUES (?, ?, ?, ?, ?, ?, ?)
	`, id, userID, name, provider, enabled, apiKey, customAPIURL)
	return err
}

// CreateExchange åˆ›å»ºäº¤æ˜“æ‰€é…ç½®
func (d *Database) CreateExchange(userID, id, name, typ string, enabled bool, apiKey, secretKey string, testnet bool, hyperliquidWalletAddr, asterUser, asterSigner, asterPrivateKey string) error {
	// åŠ å¯†æ•æ„Ÿå­—æ®µ
	encryptedAPIKey := d.encryptSensitiveData(apiKey)
	encryptedSecretKey := d.encryptSensitiveData(secretKey)
	encryptedAsterPrivateKey := d.encryptSensitiveData(asterPrivateKey)

	_, err := d.db.Exec(`
		INSERT OR IGNORE INTO exchanges (id, user_id, name, type, enabled, api_key, secret_key, testnet, hyperliquid_wallet_addr, aster_user, aster_signer, aster_private_key, lighter_wallet_addr, lighter_private_key)
		VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, '', '')
	`, id, userID, name, typ, enabled, encryptedAPIKey, encryptedSecretKey, testnet, hyperliquidWalletAddr, asterUser, asterSigner, encryptedAsterPrivateKey)
	return err
}

// CreateTrader åˆ›å»ºäº¤æ˜“å‘˜
func (d *Database) CreateTrader(trader *TraderRecord) error {
	_, err := d.db.Exec(`
		INSERT INTO traders (id, user_id, name, ai_model_id, exchange_id, initial_balance, scan_interval_minutes, is_running, btc_eth_leverage, altcoin_leverage, trading_symbols, use_coin_pool, use_oi_top, custom_prompt, override_base_prompt, system_prompt_template, is_cross_margin)
		VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
	`, trader.ID, trader.UserID, trader.Name, trader.AIModelID, trader.ExchangeID, trader.InitialBalance, trader.ScanIntervalMinutes, trader.IsRunning, trader.BTCETHLeverage, trader.AltcoinLeverage, trader.TradingSymbols, trader.UseCoinPool, trader.UseOITop, trader.CustomPrompt, trader.OverrideBasePrompt, trader.SystemPromptTemplate, trader.IsCrossMargin)
	return err
}

// GetTraders è·å–ç”¨æˆ·çš„äº¤æ˜“å‘˜
func (d *Database) GetTraders(userID string) ([]*TraderRecord, error) {
	rows, err := d.db.Query(`
		SELECT id, user_id, name, ai_model_id, exchange_id, initial_balance, scan_interval_minutes, is_running,
		       COALESCE(btc_eth_leverage, 5) as btc_eth_leverage, COALESCE(altcoin_leverage, 5) as altcoin_leverage,
		       COALESCE(trading_symbols, '') as trading_symbols,
		       COALESCE(use_coin_pool, 0) as use_coin_pool, COALESCE(use_oi_top, 0) as use_oi_top,
		       COALESCE(custom_prompt, '') as custom_prompt, COALESCE(override_base_prompt, 0) as override_base_prompt,
		       COALESCE(system_prompt_template, 'default') as system_prompt_template,
		       COALESCE(is_cross_margin, 1) as is_cross_margin, created_at, updated_at
		FROM traders WHERE user_id = ? ORDER BY created_at DESC
	`, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var traders []*TraderRecord
	for rows.Next() {
		var trader TraderRecord
		err := rows.Scan(
			&trader.ID, &trader.UserID, &trader.Name, &trader.AIModelID, &trader.ExchangeID,
			&trader.InitialBalance, &trader.ScanIntervalMinutes, &trader.IsRunning,
			&trader.BTCETHLeverage, &trader.AltcoinLeverage, &trader.TradingSymbols,
			&trader.UseCoinPool, &trader.UseOITop,
			&trader.CustomPrompt, &trader.OverrideBasePrompt, &trader.SystemPromptTemplate,
			&trader.IsCrossMargin,
			&trader.CreatedAt, &trader.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}
		traders = append(traders, &trader)
	}

	return traders, nil
}

// UpdateTraderStatus æ›´æ–°äº¤æ˜“å‘˜çŠ¶æ€
func (d *Database) UpdateTraderStatus(userID, id string, isRunning bool) error {
	_, err := d.db.Exec(`UPDATE traders SET is_running = ? WHERE id = ? AND user_id = ?`, isRunning, id, userID)
	return err
}

// UpdateTrader æ›´æ–°äº¤æ˜“å‘˜é…ç½®
func (d *Database) UpdateTrader(trader *TraderRecord) error {
	_, err := d.db.Exec(`
		UPDATE traders SET
			name = ?, ai_model_id = ?, exchange_id = ?,
			scan_interval_minutes = ?, btc_eth_leverage = ?, altcoin_leverage = ?,
			trading_symbols = ?, custom_prompt = ?, override_base_prompt = ?,
			system_prompt_template = ?, is_cross_margin = ?, updated_at = CURRENT_TIMESTAMP
		WHERE id = ? AND user_id = ?
	`, trader.Name, trader.AIModelID, trader.ExchangeID,
		trader.ScanIntervalMinutes, trader.BTCETHLeverage, trader.AltcoinLeverage,
		trader.TradingSymbols, trader.CustomPrompt, trader.OverrideBasePrompt,
		trader.SystemPromptTemplate, trader.IsCrossMargin, trader.ID, trader.UserID)
	return err
}

// UpdateTraderCustomPrompt æ›´æ–°äº¤æ˜“å‘˜è‡ªå®šä¹‰Prompt
func (d *Database) UpdateTraderCustomPrompt(userID, id string, customPrompt string, overrideBase bool) error {
	_, err := d.db.Exec(`UPDATE traders SET custom_prompt = ?, override_base_prompt = ? WHERE id = ? AND user_id = ?`, customPrompt, overrideBase, id, userID)
	return err
}

// UpdateTraderInitialBalance æ›´æ–°äº¤æ˜“å‘˜åˆå§‹ä½™é¢ï¼ˆä»…æ”¯æŒæ‰‹åŠ¨æ›´æ–°ï¼‰
// âš ï¸ æ³¨æ„ï¼šç³»ç»Ÿä¸ä¼šè‡ªåŠ¨è°ƒç”¨æ­¤æ–¹æ³•ï¼Œä»…ä¾›ç”¨æˆ·åœ¨å……å€¼/æç°åæ‰‹åŠ¨åŒæ­¥ä½¿ç”¨
func (d *Database) UpdateTraderInitialBalance(userID, id string, newBalance float64) error {
	_, err := d.db.Exec(`UPDATE traders SET initial_balance = ? WHERE id = ? AND user_id = ?`, newBalance, id, userID)
	return err
}

// DeleteTrader åˆ é™¤äº¤æ˜“å‘˜
func (d *Database) DeleteTrader(userID, id string) error {
	_, err := d.db.Exec(`DELETE FROM traders WHERE id = ? AND user_id = ?`, id, userID)
	return err
}

// GetTraderConfig è·å–äº¤æ˜“å‘˜å®Œæ•´é…ç½®ï¼ˆåŒ…å«AIæ¨¡å‹å’Œäº¤æ˜“æ‰€ä¿¡æ¯ï¼‰
func (d *Database) GetTraderConfig(userID, traderID string) (*TraderRecord, *AIModelConfig, *ExchangeConfig, error) {
	var trader TraderRecord
	var aiModel AIModelConfig
	var exchange ExchangeConfig

	err := d.db.QueryRow(`
		SELECT
			t.id, t.user_id, t.name, t.ai_model_id, t.exchange_id, t.initial_balance, t.scan_interval_minutes, t.is_running,
			COALESCE(t.btc_eth_leverage, 5) as btc_eth_leverage,
			COALESCE(t.altcoin_leverage, 5) as altcoin_leverage,
			COALESCE(t.trading_symbols, '') as trading_symbols,
			COALESCE(t.use_coin_pool, 0) as use_coin_pool,
			COALESCE(t.use_oi_top, 0) as use_oi_top,
			COALESCE(t.custom_prompt, '') as custom_prompt,
			COALESCE(t.override_base_prompt, 0) as override_base_prompt,
			COALESCE(t.system_prompt_template, 'default') as system_prompt_template,
			COALESCE(t.is_cross_margin, 1) as is_cross_margin,
			t.created_at, t.updated_at,
			a.id, a.user_id, a.name, a.provider, a.enabled, a.api_key,
			COALESCE(a.custom_api_url, '') as custom_api_url,
			COALESCE(a.custom_model_name, '') as custom_model_name,
			a.created_at, a.updated_at,
			e.id, e.user_id, e.name, e.type, e.enabled, e.api_key, e.secret_key, e.testnet,
			COALESCE(e.hyperliquid_wallet_addr, '') as hyperliquid_wallet_addr,
			COALESCE(e.aster_user, '') as aster_user,
			COALESCE(e.aster_signer, '') as aster_signer,
			COALESCE(e.aster_private_key, '') as aster_private_key,
			COALESCE(e.lighter_wallet_addr, '') as lighter_wallet_addr,
			COALESCE(e.lighter_private_key, '') as lighter_private_key,
			e.created_at, e.updated_at
		FROM traders t
		JOIN ai_models a ON t.ai_model_id = a.id AND t.user_id = a.user_id
		JOIN exchanges e ON t.exchange_id = e.id AND t.user_id = e.user_id
		WHERE t.id = ? AND t.user_id = ?
	`, traderID, userID).Scan(
		&trader.ID, &trader.UserID, &trader.Name, &trader.AIModelID, &trader.ExchangeID,
		&trader.InitialBalance, &trader.ScanIntervalMinutes, &trader.IsRunning,
		&trader.BTCETHLeverage, &trader.AltcoinLeverage, &trader.TradingSymbols,
		&trader.UseCoinPool, &trader.UseOITop,
		&trader.CustomPrompt, &trader.OverrideBasePrompt, &trader.SystemPromptTemplate,
		&trader.IsCrossMargin,
		&trader.CreatedAt, &trader.UpdatedAt,
		&aiModel.ID, &aiModel.UserID, &aiModel.Name, &aiModel.Provider, &aiModel.Enabled, &aiModel.APIKey,
		&aiModel.CustomAPIURL, &aiModel.CustomModelName,
		&aiModel.CreatedAt, &aiModel.UpdatedAt,
		&exchange.ID, &exchange.UserID, &exchange.Name, &exchange.Type, &exchange.Enabled,
		&exchange.APIKey, &exchange.SecretKey, &exchange.Testnet,
		&exchange.HyperliquidWalletAddr, &exchange.AsterUser, &exchange.AsterSigner, &exchange.AsterPrivateKey,
		&exchange.LighterWalletAddr, &exchange.LighterPrivateKey,
		&exchange.CreatedAt, &exchange.UpdatedAt,
	)

	if err != nil {
		return nil, nil, nil, err
	}

	// è§£å¯†æ•æ„Ÿæ•°æ®
	aiModel.APIKey = d.decryptSensitiveData(aiModel.APIKey)
	exchange.APIKey = d.decryptSensitiveData(exchange.APIKey)
	exchange.SecretKey = d.decryptSensitiveData(exchange.SecretKey)
	exchange.AsterPrivateKey = d.decryptSensitiveData(exchange.AsterPrivateKey)
	exchange.LighterPrivateKey = d.decryptSensitiveData(exchange.LighterPrivateKey)

	return &trader, &aiModel, &exchange, nil
}

// GetSystemConfig è·å–ç³»ç»Ÿé…ç½®
func (d *Database) GetSystemConfig(key string) (string, error) {
	var value string
	err := d.db.QueryRow(`SELECT value FROM system_config WHERE key = ?`, key).Scan(&value)
	return value, err
}

// SetSystemConfig è®¾ç½®ç³»ç»Ÿé…ç½®
func (d *Database) SetSystemConfig(key, value string) error {
	_, err := d.db.Exec(`
		INSERT OR REPLACE INTO system_config (key, value) VALUES (?, ?)
	`, key, value)
	return err
}

// CreateUserSignalSource åˆ›å»ºç”¨æˆ·ä¿¡å·æºé…ç½®
func (d *Database) CreateUserSignalSource(userID, coinPoolURL, oiTopURL string) error {
	_, err := d.db.Exec(`
		INSERT OR REPLACE INTO user_signal_sources (user_id, coin_pool_url, oi_top_url, updated_at)
		VALUES (?, ?, ?, CURRENT_TIMESTAMP)
	`, userID, coinPoolURL, oiTopURL)
	return err
}

// GetUserSignalSource è·å–ç”¨æˆ·ä¿¡å·æºé…ç½®
func (d *Database) GetUserSignalSource(userID string) (*UserSignalSource, error) {
	var source UserSignalSource
	err := d.db.QueryRow(`
		SELECT id, user_id, coin_pool_url, oi_top_url, created_at, updated_at
		FROM user_signal_sources WHERE user_id = ?
	`, userID).Scan(
		&source.ID, &source.UserID, &source.CoinPoolURL, &source.OITopURL,
		&source.CreatedAt, &source.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}
	return &source, nil
}

// UpdateUserSignalSource æ›´æ–°ç”¨æˆ·ä¿¡å·æºé…ç½®
func (d *Database) UpdateUserSignalSource(userID, coinPoolURL, oiTopURL string) error {
	_, err := d.db.Exec(`
		UPDATE user_signal_sources SET coin_pool_url = ?, oi_top_url = ?, updated_at = CURRENT_TIMESTAMP
		WHERE user_id = ?
	`, coinPoolURL, oiTopURL, userID)
	return err
}

// GetCustomCoins è·å–æ‰€æœ‰äº¤æ˜“å‘˜è‡ªå®šä¹‰å¸ç§ / Get all trader-customized currencies
func (d *Database) GetCustomCoins() []string {
	var symbol string
	var symbols []string
	_ = d.db.QueryRow(`
		SELECT GROUP_CONCAT(custom_coins , ',') as symbol
		FROM main.traders where custom_coins != ''
	`).Scan(&symbol)
	// æ£€æµ‹ç”¨æˆ·æ˜¯å¦æœªé…ç½®å¸ç§ - å…¼å®¹æ€§
	if symbol == "" {
		symbolJSON, _ := d.GetSystemConfig("default_coins")
		if err := json.Unmarshal([]byte(symbolJSON), &symbols); err != nil {
			log.Printf("âš ï¸  è§£ædefault_coinsé…ç½®å¤±è´¥: %vï¼Œä½¿ç”¨ç¡¬ç¼–ç é»˜è®¤å€¼", err)
			symbols = []string{"BTCUSDT", "ETHUSDT", "SOLUSDT", "BNBUSDT"}
		}
	}
	// filter Symbol
	for _, s := range strings.Split(symbol, ",") {
		if s == "" {
			continue
		}
		coin := market.Normalize(s)
		if !slices.Contains(symbols, coin) {
			symbols = append(symbols, coin)
		}
	}
	return symbols
}

// Close å…³é—­æ•°æ®åº“è¿æ¥
// Conn è¿”å›åº•å±‚ *sql.DBï¼Œä¾›éœ€è¦æ‰§è¡Œè‡ªå®šä¹‰æŸ¥è¯¢çš„æ¨¡å—ä½¿ç”¨ã€‚
func (d *Database) Conn() *sql.DB {
	return d.db
}

func (d *Database) Close() error {
	return d.db.Close()
}

// LoadBetaCodesFromFile ä»æ–‡ä»¶åŠ è½½å†…æµ‹ç åˆ°æ•°æ®åº“
func (d *Database) LoadBetaCodesFromFile(filePath string) error {
	// è¯»å–æ–‡ä»¶å†…å®¹
	content, err := os.ReadFile(filePath)
	if err != nil {
		return fmt.Errorf("è¯»å–å†…æµ‹ç æ–‡ä»¶å¤±è´¥: %w", err)
	}

	// æŒ‰è¡Œåˆ†å‰²å†…æµ‹ç 
	lines := strings.Split(string(content), "\n")
	var codes []string
	for _, line := range lines {
		code := strings.TrimSpace(line)
		if code != "" && !strings.HasPrefix(code, "#") {
			codes = append(codes, code)
		}
	}

	// æ‰¹é‡æ’å…¥å†…æµ‹ç 
	tx, err := d.db.Begin()
	if err != nil {
		return fmt.Errorf("å¼€å§‹äº‹åŠ¡å¤±è´¥: %w", err)
	}
	defer tx.Rollback()

	stmt, err := tx.Prepare(`INSERT OR IGNORE INTO beta_codes (code) VALUES (?)`)
	if err != nil {
		return fmt.Errorf("å‡†å¤‡è¯­å¥å¤±è´¥: %w", err)
	}
	defer stmt.Close()

	insertedCount := 0
	for _, code := range codes {
		result, err := stmt.Exec(code)
		if err != nil {
			log.Printf("æ’å…¥å†…æµ‹ç  %s å¤±è´¥: %v", code, err)
			continue
		}

		if rowsAffected, _ := result.RowsAffected(); rowsAffected > 0 {
			insertedCount++
		}
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("æäº¤äº‹åŠ¡å¤±è´¥: %w", err)
	}

	log.Printf("âœ… æˆåŠŸåŠ è½½ %d ä¸ªå†…æµ‹ç åˆ°æ•°æ®åº“ (æ€»è®¡ %d ä¸ª)", insertedCount, len(codes))
	return nil
}

// ValidateBetaCode éªŒè¯å†…æµ‹ç æ˜¯å¦æœ‰æ•ˆä¸”æœªä½¿ç”¨
func (d *Database) ValidateBetaCode(code string) (bool, error) {
	var used bool
	err := d.db.QueryRow(`SELECT used FROM beta_codes WHERE code = ?`, code).Scan(&used)
	if err != nil {
		if err == sql.ErrNoRows {
			return false, nil // å†…æµ‹ç ä¸å­˜åœ¨
		}
		return false, err
	}
	return !used, nil // å†…æµ‹ç å­˜åœ¨ä¸”æœªä½¿ç”¨
}

// UseBetaCode ä½¿ç”¨å†…æµ‹ç ï¼ˆæ ‡è®°ä¸ºå·²ä½¿ç”¨ï¼‰
func (d *Database) UseBetaCode(code, userEmail string) error {
	result, err := d.db.Exec(`
		UPDATE beta_codes SET used = 1, used_by = ?, used_at = CURRENT_TIMESTAMP 
		WHERE code = ? AND used = 0
	`, userEmail, code)
	if err != nil {
		return err
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return err
	}

	if rowsAffected == 0 {
		return fmt.Errorf("å†…æµ‹ç æ— æ•ˆæˆ–å·²è¢«ä½¿ç”¨")
	}

	return nil
}

// GetBetaCodeStats è·å–å†…æµ‹ç ç»Ÿè®¡ä¿¡æ¯
func (d *Database) GetBetaCodeStats() (total, used int, err error) {
	err = d.db.QueryRow(`SELECT COUNT(*) FROM beta_codes`).Scan(&total)
	if err != nil {
		return 0, 0, err
	}

	err = d.db.QueryRow(`SELECT COUNT(*) FROM beta_codes WHERE used = 1`).Scan(&used)
	if err != nil {
		return 0, 0, err
	}

	return total, used, nil
}

// SetCryptoService è®¾ç½®åŠ å¯†æœåŠ¡
func (d *Database) SetCryptoService(cs *crypto.CryptoService) {
	d.cryptoService = cs
}

// encryptSensitiveData åŠ å¯†æ•æ„Ÿæ•°æ®ç”¨äºå­˜å‚¨
func (d *Database) encryptSensitiveData(plaintext string) string {
	if d.cryptoService == nil || plaintext == "" {
		return plaintext
	}

	encrypted, err := d.cryptoService.EncryptForStorage(plaintext)
	if err != nil {
		log.Printf("âš ï¸ åŠ å¯†å¤±è´¥: %v", err)
		return plaintext // è¿”å›æ˜æ–‡ä½œä¸ºé™çº§å¤„ç†
	}

	return encrypted
}

// decryptSensitiveData è§£å¯†æ•æ„Ÿæ•°æ®
func (d *Database) decryptSensitiveData(encrypted string) string {
	if d.cryptoService == nil || encrypted == "" {
		return encrypted
	}

	// å¦‚æœä¸æ˜¯åŠ å¯†æ ¼å¼ï¼Œç›´æ¥è¿”å›
	if !d.cryptoService.IsEncryptedStorageValue(encrypted) {
		return encrypted
	}

	decrypted, err := d.cryptoService.DecryptFromStorage(encrypted)
	if err != nil {
		log.Printf("âš ï¸ è§£å¯†å¤±è´¥: %v", err)
		return encrypted // è¿”å›åŠ å¯†æ–‡æœ¬ä½œä¸ºé™çº§å¤„ç†
	}

	return decrypted
}
